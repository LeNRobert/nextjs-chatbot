"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jaGF0Ym90LWFwcC8uL25vZGVfbW9kdWxlcy9haS9ub2RlX21vZHVsZXMvbmFub2lkL25vbi1zZWN1cmUvaW5kZXguanM/ZmM5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUgPSAyMSkgPT4ge1xuICByZXR1cm4gKHNpemUgPSBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGxldCBpZCA9ICcnXG4gICAgbGV0IGkgPSBzaXplXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWQgKz0gYWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiBhbHBoYWJldC5sZW5ndGgpIHwgMF1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cbn1cbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PiB7XG4gIGxldCBpZCA9ICcnXG4gIGxldCBpID0gc2l6ZVxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiA2NCkgfCAwXVxuICB9XG4gIHJldHVybiBpZFxufVxuZXhwb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId: generateId2 = generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, streamMode = \"stream-data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId: generateId2 }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamMode){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    resultMessage.id = generateId2();\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage);\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"stream-data\":\n            {\n                return await parseComplexResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onFinish (prefixMap) {\n                        if (onFinish && prefixMap.text != null) {\n                            onFinish(prefixMap.text);\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamMode;\n                throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n            }\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId2();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        streamMode,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId: generateId2\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, streamMode, onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = generateId } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        streamMode,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId2\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId2();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamMode = \"stream-data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamMode){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"stream-data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamMode;\n                    throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamMode, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamMode,\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        streamMode,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const append = async (message, requestOptions)=>{\n        var _a;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : generateId()\n                }\n            ];\n        });\n        setInput(\"\");\n        try {\n            const result = await fetch(api, {\n                method: \"POST\",\n                credentials,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (result.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    {\n                                        id: lastMessage.id,\n                                        role: lastMessage.role,\n                                        content: lastMessage.content + value\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : generateId(),\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            const errorObj = new Error(value);\n                            setError(errorObj);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input\n        }, requestOptions);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\nvar experimental_useAssistant = useAssistant;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDM0I7O0FDY3JDLElBQU1NLGlCQUFrRDtJQUN0REMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBRUEsSUFBTUcseUJBSUY7SUFDRk4sTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUNFQSxTQUFTLFFBQ1QsT0FBT0EsVUFBVSxZQUNqQixDQUFFLG9CQUFtQkEsS0FBQSxLQUNyQixPQUFPQSxNQUFNSSxhQUFBLEtBQWtCLFlBQy9CSixNQUFNSSxhQUFBLElBQWlCLFFBQ3ZCLENBQUUsV0FBVUosTUFBTUksYUFBQSxLQUNsQixDQUFFLGdCQUFlSixNQUFNSSxhQUFBLEtBQ3ZCLE9BQU9KLE1BQU1JLGFBQUEsQ0FBY04sSUFBQSxLQUFTLFlBQ3BDLE9BQU9FLE1BQU1JLGFBQUEsQ0FBY0MsU0FBQSxLQUFjLFVBQ3pDO1lBQ0EsTUFBTSxJQUFJSixNQUNSO1FBRUo7UUFFQSxPQUFPO1lBQ0xDLE1BQU07WUFDTkY7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFNTSxpQkFBNEQ7SUFDaEVULE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxDQUFDTyxNQUFNQyxPQUFBLENBQVFSLFFBQVE7WUFDekIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUVBLElBQU1TLGtCQUFvRDtJQUN4RFosTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlD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QVAsT0FBTztZQUFFakssTUFBTTtZQUFRQyxTQUFTdUs7UUFBTSxHQUFHMEI7SUFDM0M7SUFFQSxPQUFPO1FBQ0xqQztRQUNBbEY7UUFDQXdGO1FBQ0FqSztRQUNBa0s7UUFDQUM7UUFDQUk7UUFDQXVCO1FBQ0FMO1FBQ0FuQztJQUNGO0FBQ0Y7QUFLTyxJQUFNMEMsNEJBQTRCViIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1jaGF0Ym90LWFwcC8uLi91c2UtY2hhdC50cz84ODI4Iiwid2VicGFjazovL25leHRqcy1jaGF0Ym90LWFwcC8uLi8uLi9zaGFyZWQvc3RyZWFtLXBhcnRzLnRzP2M0YTgiLCJ3ZWJwYWNrOi8vbmV4dGpzLWNoYXRib3QtYXBwLy4uLy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzPzE4ZjEiLCJ3ZWJwYWNrOi8vbmV4dGpzLWNoYXRib3QtYXBwLy4uLy4uL3NoYXJlZC9nZW5lcmF0ZS1pZC50cz8wZDVmIiwid2VicGFjazovL25leHRqcy1jaGF0Ym90LWFwcC8uLi8uLi9zaGFyZWQvcGFyc2UtY29tcGxleC1yZXNwb25zZS50cz82NWUwIiwid2VicGFjazovL25leHRqcy1jaGF0Ym90LWFwcC8uLi8uLi9zaGFyZWQvdXRpbHMudHM/ZjhjZiIsIndlYnBhY2s6Ly9uZXh0anMtY2hhdGJvdC1hcHAvLi4vLi4vc2hhcmVkL2NhbGwtY2hhdC1hcGkudHM/YjU1YiIsIndlYnBhY2s6Ly9uZXh0anMtY2hhdGJvdC1hcHAvLi4vLi4vc2hhcmVkL3Byb2Nlc3MtY2hhdC1zdHJlYW0udHM/OGQ3ZiIsIndlYnBhY2s6Ly9uZXh0anMtY2hhdGJvdC1hcHAvLi4vdXNlLWNvbXBsZXRpb24udHM/YWU3ZiIsIndlYnBhY2s6Ly9uZXh0anMtY2hhdGJvdC1hcHAvLi4vLi4vc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGkudHM/ODUyNSIsIndlYnBhY2s6Ly9uZXh0anMtY2hhdGJvdC1hcHAvLi4vdXNlLWFzc2lzdGFudC50cz8yODEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiwgeyBLZXllZE11dGF0b3IgfSBmcm9tICdzd3InO1xuaW1wb3J0IHsgY2FsbENoYXRBcGkgfSBmcm9tICcuLi9zaGFyZWQvY2FsbC1jaGF0LWFwaSc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jIH0gZnJvbSAnLi4vc2hhcmVkL2dlbmVyYXRlLWlkJztcbmltcG9ydCB7IHByb2Nlc3NDaGF0U3RyZWFtIH0gZnJvbSAnLi4vc2hhcmVkL3Byb2Nlc3MtY2hhdC1zdHJlYW0nO1xuaW1wb3J0IHR5cGUge1xuICBDaGF0UmVxdWVzdCxcbiAgQ2hhdFJlcXVlc3RPcHRpb25zLFxuICBDcmVhdGVNZXNzYWdlLFxuICBJZEdlbmVyYXRvcixcbiAgSlNPTlZhbHVlLFxuICBNZXNzYWdlLFxuICBVc2VDaGF0T3B0aW9ucyxcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgUmVhY3RSZXNwb25zZVJvdyxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UsXG59IGZyb20gJy4uL3N0cmVhbXMvc3RyZWFtaW5nLXJlYWN0LXJlc3BvbnNlJztcbmV4cG9ydCB0eXBlIHsgQ3JlYXRlTWVzc2FnZSwgTWVzc2FnZSwgVXNlQ2hhdE9wdGlvbnMgfTtcblxuZXhwb3J0IHR5cGUgVXNlQ2hhdEhlbHBlcnMgPSB7XG4gIC8qKiBDdXJyZW50IG1lc3NhZ2VzIGluIHRoZSBjaGF0ICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIC8qKiBUaGUgZXJyb3Igb2JqZWN0IG9mIHRoZSBBUEkgcmVxdWVzdCAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgRXJyb3I7XG4gIC8qKlxuICAgKiBBcHBlbmQgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBhcHBlbmRcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIFJlbG9hZCB0aGUgbGFzdCBBSSBjaGF0IHJlc3BvbnNlIGZvciB0aGUgZ2l2ZW4gY2hhdCBoaXN0b3J5LiBJZiB0aGUgbGFzdFxuICAgKiBtZXNzYWdlIGlzbid0IGZyb20gdGhlIGFzc2lzdGFudCwgaXQgd2lsbCByZXF1ZXN0IHRoZSBBUEkgdG8gZ2VuZXJhdGUgYVxuICAgKiBuZXcgcmVzcG9uc2UuXG4gICAqL1xuICByZWxvYWQ6IChcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYG1lc3NhZ2VzYCBzdGF0ZSBsb2NhbGx5LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvXG4gICAqIGVkaXQgdGhlIG1lc3NhZ2VzIG9uIHRoZSBjbGllbnQsIGFuZCB0aGVuIHRyaWdnZXIgdGhlIGByZWxvYWRgIG1ldGhvZFxuICAgKiBtYW51YWxseSB0byByZWdlbmVyYXRlIHRoZSBBSSByZXNwb25zZS5cbiAgICovXG4gIHNldE1lc3NhZ2VzOiAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4gdm9pZDtcbiAgLyoqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBpbnB1dDogc3RyaW5nO1xuICAvKiogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIC8qKiBBbiBpbnB1dC90ZXh0YXJlYS1yZWFkeSBvbkNoYW5nZSBoYW5kbGVyIHRvIGNvbnRyb2wgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2UgKi9cbiAgaGFuZGxlU3VibWl0OiAoXG4gICAgZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IHZvaWQ7XG4gIG1ldGFkYXRhPzogT2JqZWN0O1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdO1xufTtcblxudHlwZSBTdHJlYW1pbmdSZWFjdFJlc3BvbnNlQWN0aW9uID0gKHBheWxvYWQ6IHtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59KSA9PiBQcm9taXNlPGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlPjtcblxuY29uc3QgZ2V0U3RyZWFtZWRSZXNwb25zZSA9IGFzeW5jIChcbiAgYXBpOiBzdHJpbmcgfCBTdHJlYW1pbmdSZWFjdFJlc3BvbnNlQWN0aW9uLFxuICBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QsXG4gIG11dGF0ZTogS2V5ZWRNdXRhdG9yPE1lc3NhZ2VbXT4sXG4gIG11dGF0ZVN0cmVhbURhdGE6IEtleWVkTXV0YXRvcjxKU09OVmFsdWVbXSB8IHVuZGVmaW5lZD4sXG4gIGV4aXN0aW5nRGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQsXG4gIGV4dHJhTWV0YWRhdGFSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8YW55PixcbiAgbWVzc2FnZXNSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8TWVzc2FnZVtdPixcbiAgYWJvcnRDb250cm9sbGVyUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEFib3J0Q29udHJvbGxlciB8IG51bGw+LFxuICBnZW5lcmF0ZUlkOiBJZEdlbmVyYXRvcixcbiAgc3RyZWFtTW9kZT86ICdzdHJlYW0tZGF0YScgfCAndGV4dCcsXG4gIG9uRmluaXNoPzogKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHZvaWQsXG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPixcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcz86IGJvb2xlYW4sXG4pID0+IHtcbiAgLy8gRG8gYW4gb3B0aW1pc3RpYyB1cGRhdGUgdG8gdGhlIGNoYXQgc3RhdGUgdG8gc2hvdyB0aGUgdXBkYXRlZCBtZXNzYWdlc1xuICAvLyBpbW1lZGlhdGVseS5cbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gIG11dGF0ZShjaGF0UmVxdWVzdC5tZXNzYWdlcywgZmFsc2UpO1xuXG4gIGNvbnN0IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkID0gc2VuZEV4dHJhTWVzc2FnZUZpZWxkc1xuICAgID8gY2hhdFJlcXVlc3QubWVzc2FnZXNcbiAgICA6IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLm1hcChcbiAgICAgICAgKHsgcm9sZSwgY29udGVudCwgbmFtZSwgZnVuY3Rpb25fY2FsbCwgdG9vbF9jYWxscywgdG9vbF9jYWxsX2lkIH0pID0+ICh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAuLi4obmFtZSAhPT0gdW5kZWZpbmVkICYmIHsgbmFtZSB9KSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uKHRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sX2NhbGxzLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgaWYgKHR5cGVvZiBhcGkgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBhcmUgaGFuZGxpbmcgYSBTZXJ2ZXIgQWN0aW9uLiBObyBjb21wbGV4IG1vZGUgaGFuZGxpbmcgbmVlZGVkLlxuXG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRSb3cocHJvbWlzZTogUHJvbWlzZTxSZWFjdFJlc3BvbnNlUm93Pikge1xuICAgICAgY29uc3QgeyBjb250ZW50LCB1aSwgbmV4dCB9ID0gYXdhaXQgcHJvbWlzZTtcblxuICAgICAgLy8gVE9ETzogSGFuZGxlIGZ1bmN0aW9uIGNhbGxzLlxuICAgICAgcmVzcG9uc2VNZXNzYWdlWydjb250ZW50J10gPSBjb250ZW50O1xuICAgICAgcmVzcG9uc2VNZXNzYWdlWyd1aSddID0gYXdhaXQgdWk7XG5cbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIHsgLi4ucmVzcG9uc2VNZXNzYWdlIH1dLCBmYWxzZSk7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBhcGkoe1xuICAgICAgICBtZXNzYWdlczogY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgYXMgTWVzc2FnZVtdLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgfSkgYXMgUHJvbWlzZTxSZWFjdFJlc3BvbnNlUm93PjtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgbWVzc2FnZXMgaWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBjYWxsQ2hhdEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi5jaGF0UmVxdWVzdC5vcHRpb25zPy5ib2R5LFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnMsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QudG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIHRvb2xzOiBjaGF0UmVxdWVzdC50b29scyxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICB0b29sX2Nob2ljZTogY2hhdFJlcXVlc3QudG9vbF9jaG9pY2UsXG4gICAgICB9KSxcbiAgICB9LFxuICAgIHN0cmVhbU1vZGUsXG4gICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0Lm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgfSxcbiAgICBhYm9ydENvbnRyb2xsZXI6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LFxuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpIHtcbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvblJlc3BvbnNlLFxuICAgIG9uVXBkYXRlKG1lcmdlZCwgZGF0YSkge1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgLi4ubWVyZ2VkXSwgZmFsc2UpO1xuICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uKGV4aXN0aW5nRGF0YSB8fCBbXSksIC4uLihkYXRhIHx8IFtdKV0sIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQsXG4gIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSAnL2FwaS9jaGF0JyxcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyxcbiAgaW5pdGlhbElucHV0ID0gJycsXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHN0cmVhbU1vZGUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZ2VuZXJhdGVJZCA9IGdlbmVyYXRlSWRGdW5jLFxufTogT21pdDxVc2VDaGF0T3B0aW9ucywgJ2FwaSc+ICYge1xuICBhcGk/OiBzdHJpbmcgfCBTdHJlYW1pbmdSZWFjdFJlc3BvbnNlQWN0aW9uO1xuICBrZXk/OiBzdHJpbmc7XG59ID0ge30pOiBVc2VDaGF0SGVscGVycyB7XG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkIGZvciB0aGUgY2hhdCBpZiBub3QgcHJvdmlkZWQuXG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGlkS2V5ID0gaWQgPz8gaG9va0lkO1xuICBjb25zdCBjaGF0S2V5ID0gdHlwZW9mIGFwaSA9PT0gJ3N0cmluZycgPyBbYXBpLCBpZEtleV0gOiBpZEtleTtcblxuICAvLyBTdG9yZSBhIGVtcHR5IGFycmF5IGFzIHRoZSBpbml0aWFsIG1lc3NhZ2VzXG4gIC8vIChpbnN0ZWFkIG9mIHVzaW5nIGEgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUgdGhhdCBnZXRzIHJlLWNyZWF0ZWQgZWFjaCB0aW1lKVxuICAvLyB0byBhdm9pZCByZS1yZW5kZXJzOlxuICBjb25zdCBbaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2tdID0gdXNlU3RhdGUoW10pO1xuXG4gIC8vIFN0b3JlIHRoZSBjaGF0IHN0YXRlIGluIFNXUiwgdXNpbmcgdGhlIGNoYXRJZCBhcyB0aGUga2V5IHRvIHNoYXJlIHN0YXRlcy5cbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1I8TWVzc2FnZVtdPihcbiAgICBbY2hhdEtleSwgJ21lc3NhZ2VzJ10sXG4gICAgbnVsbCxcbiAgICB7IGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzID8/IGluaXRpYWxNZXNzYWdlc0ZhbGxiYWNrIH0sXG4gICk7XG5cbiAgLy8gV2Ugc3RvcmUgbG9hZGluZyBzdGF0ZSBpbiBhbm90aGVyIGhvb2sgdG8gc3luYyBsb2FkaW5nIHN0YXRlcyBhY3Jvc3MgaG9vayBpbnZvY2F0aW9uc1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjxib29sZWFuPihcbiAgICBbY2hhdEtleSwgJ2xvYWRpbmcnXSxcbiAgICBudWxsLFxuICApO1xuXG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1I8XG4gICAgSlNPTlZhbHVlW10gfCB1bmRlZmluZWRcbiAgPihbY2hhdEtleSwgJ3N0cmVhbURhdGEnXSwgbnVsbCk7XG5cbiAgY29uc3QgeyBkYXRhOiBlcnJvciA9IHVuZGVmaW5lZCwgbXV0YXRlOiBzZXRFcnJvciB9ID0gdXNlU1dSPFxuICAgIHVuZGVmaW5lZCB8IEVycm9yXG4gID4oW2NoYXRLZXksICdlcnJvciddLCBudWxsKTtcblxuICAvLyBLZWVwIHRoZSBsYXRlc3QgbWVzc2FnZXMgaW4gYSByZWYuXG4gIGNvbnN0IG1lc3NhZ2VzUmVmID0gdXNlUmVmPE1lc3NhZ2VbXT4obWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgLy8gQWJvcnQgY29udHJvbGxlciB0byBjYW5jZWwgdGhlIGN1cnJlbnQgQVBJIGNhbGwuXG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZjxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gIH0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcblxuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcblxuICAgICAgICBhd2FpdCBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZTogKCkgPT5cbiAgICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2UoXG4gICAgICAgICAgICAgIGFwaSxcbiAgICAgICAgICAgICAgY2hhdFJlcXVlc3QsXG4gICAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgICAgICAgICAgc3RyZWFtRGF0YSEsXG4gICAgICAgICAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzUmVmLFxuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICAgICAgICAgIGdlbmVyYXRlSWQsXG4gICAgICAgICAgICAgIHN0cmVhbU1vZGUsXG4gICAgICAgICAgICAgIG9uRmluaXNoLFxuICAgICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3Q6IGNoYXRSZXF1ZXN0UGFyYW0gPT4ge1xuICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBjaGF0UmVxdWVzdFBhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICB9KTtcblxuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gSWdub3JlIGFib3J0IGVycm9ycyBhcyB0aGV5IGFyZSBleHBlY3RlZC5cbiAgICAgICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1Nb2RlLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICBnZW5lcmF0ZUlkLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgICB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHRvb2xfY2hvaWNlLFxuICAgICAgICBkYXRhLFxuICAgICAgfTogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgKSA9PiB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQobWVzc2FnZSBhcyBNZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3QsIGdlbmVyYXRlSWRdLFxuICApO1xuXG4gIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh7XG4gICAgICBvcHRpb25zLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgIHRvb2xzLFxuICAgICAgdG9vbF9jaG9pY2UsXG4gICAgfTogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIFJlbW92ZSBsYXN0IGFzc2lzdGFudCBtZXNzYWdlIGFuZCByZXRyeSBsYXN0IHVzZXIgbWVzc2FnZS5cbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XSxcbiAgKTtcblxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKFxuICAgIChtZXNzYWdlczogTWVzc2FnZVtdKSA9PiB7XG4gICAgICBtdXRhdGUobWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcztcbiAgICB9LFxuICAgIFttdXRhdGVdLFxuICApO1xuXG4gIC8vIElucHV0IHN0YXRlIGFuZCBoYW5kbGVycy5cbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgICAgb3B0aW9uczogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgICBtZXRhZGF0YT86IE9iamVjdCxcbiAgICApID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm47XG5cbiAgICAgIGFwcGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgc2V0SW5wdXQoJycpO1xuICAgIH0sXG4gICAgW2lucHV0LCBhcHBlbmRdLFxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGU6IGFueSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgQXNzaXN0YW50TWVzc2FnZSxcbiAgRGF0YU1lc3NhZ2UsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdHJlYW1TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1QYXJ0PENPREUgZXh0ZW5kcyBzdHJpbmcsIE5BTUUgZXh0ZW5kcyBzdHJpbmcsIFRZUEU+IHtcbiAgY29kZTogQ09ERTtcbiAgbmFtZTogTkFNRTtcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7IHR5cGU6IE5BTUU7IHZhbHVlOiBUWVBFIH07XG59XG5cbmNvbnN0IHRleHRTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcwJywgJ3RleHQnLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMCcsXG4gIG5hbWU6ICd0ZXh0JyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAndGV4dCcsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnMScsXG4gICdmdW5jdGlvbl9jYWxsJyxcbiAgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfVxuPiA9IHtcbiAgY29kZTogJzEnLFxuICBuYW1lOiAnZnVuY3Rpb25fY2FsbCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2Z1bmN0aW9uX2NhbGwnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS5mdW5jdGlvbl9jYWxsID09IG51bGwgfHxcbiAgICAgICEoJ25hbWUnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICAhKCdhcmd1bWVudHMnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcyJywgJ2RhdGEnLCBBcnJheTxKU09OVmFsdWU+PiA9IHtcbiAgY29kZTogJzInLFxuICBuYW1lOiAnZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdkYXRhJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGVycm9yU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMycsICdlcnJvcicsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICczJyxcbiAgbmFtZTogJ2Vycm9yJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2Vycm9yJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNCcsXG4gICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIEFzc2lzdGFudE1lc3NhZ2Vcbj4gPSB7XG4gIGNvZGU6ICc0JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnaWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdjb250ZW50JyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2Fzc2lzdGFudCcgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8XG4gICAgICAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgICAgaXRlbSA9PlxuICAgICAgICAgIGl0ZW0gIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd0eXBlJyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgICAndGV4dCcgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndmFsdWUnIGluIGl0ZW0udGV4dCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgQXNzaXN0YW50TWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNScsXG4gICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAge1xuICAgIHRocmVhZElkOiBzdHJpbmc7XG4gICAgbWVzc2FnZUlkOiBzdHJpbmc7XG4gIH1cbj4gPSB7XG4gIGNvZGU6ICc1JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0aHJlYWRJZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdtZXNzYWdlSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDwnNicsICdkYXRhX21lc3NhZ2UnLCBEYXRhTWVzc2FnZT4gPSB7XG4gIGNvZGU6ICc2JyxcbiAgbmFtZTogJ2RhdGFfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnZGF0YScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdkYXRhJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkYXRhX21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIERhdGFNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc3JyxcbiAgJ3Rvb2xfY2FsbHMnLFxuICB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfVxuPiA9IHtcbiAgY29kZTogJzcnLFxuICBuYW1lOiAndG9vbF9jYWxscycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xfY2FsbHMnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xfY2FsbHMgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnRvb2xfY2FsbHMpIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAgIHRjID0+XG4gICAgICAgICAgdGMgPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0YyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdpZCcgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ3R5cGUnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy50eXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ2Z1bmN0aW9uJyBpbiB0YykgfHxcbiAgICAgICAgICB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2FyZ3VtZW50cycgaW4gdGMuZnVuY3Rpb24pIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX2NhbGxzJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnOCcsXG4gICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgQXJyYXk8SlNPTlZhbHVlPlxuPiA9IHtcbiAgY29kZTogJzgnLFxuICBuYW1lOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdtZXNzYWdlX2Fubm90YXRpb25zJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG5dIGFzIGNvbnN0O1xuXG4vLyB1bmlvbiB0eXBlIG9mIGFsbCBzdHJlYW0gcGFydHNcbnR5cGUgU3RyZWFtUGFydHMgPVxuICB8IHR5cGVvZiB0ZXh0U3RyZWFtUGFydFxuICB8IHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGVycm9yU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0O1xuLyoqXG4gKiBNYXBzIHRoZSB0eXBlIG9mIGEgc3RyZWFtIHBhcnQgdG8gaXRzIHZhbHVlIHR5cGUuXG4gKi9cbnR5cGUgU3RyZWFtUGFydFZhbHVlVHlwZSA9IHtcbiAgW1AgaW4gU3RyZWFtUGFydHMgYXMgUFsnbmFtZSddXTogUmV0dXJuVHlwZTxQWydwYXJzZSddPlsndmFsdWUnXTtcbn07XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVBhcnRUeXBlID1cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0ZXh0U3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGVycm9yU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LnBhcnNlPjtcblxuZXhwb3J0IGNvbnN0IHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogVGhlIG1hcCBvZiBwcmVmaXhlcyBmb3IgZGF0YSBpbiB0aGUgc3RyZWFtXG4gKlxuICogLSAwOiBUZXh0IGZyb20gdGhlIExMTSByZXNwb25zZVxuICogLSAxOiAoT3BlbkFJKSBmdW5jdGlvbl9jYWxsIHJlc3BvbnNlc1xuICogLSAyOiBjdXN0b20gSlNPTiBhZGRlZCBieSB0aGUgdXNlciB1c2luZyBgRGF0YWBcbiAqIC0gNjogKE9wZW5BSSkgdG9vbF9jYWxsIHJlc3BvbnNlc1xuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIDA6VmVyY2VsXG4gKiAwOidzXG4gKiAwOiBBSVxuICogMDogQUlcbiAqIDA6IFNES1xuICogMDogaXMgZ3JlYXRcbiAqIDA6IVxuICogMjogeyBcInNvbWVKc29uXCI6IFwidmFsdWVcIiB9XG4gKiAxOiB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19XG4gKiA2OiB7XCJ0b29sX2NhbGxcIjoge1wiaWRcIjogXCJ0b29sXzBcIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fX1cbiAqYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcChwYXJ0ID0+IHBhcnQuY29kZSk7XG5cbi8qKlxuUGFyc2VzIGEgc3RyZWFtIHBhcnQgZnJvbSBhIHN0cmluZy5cblxuQHBhcmFtIGxpbmUgVGhlIHN0cmluZyB0byBwYXJzZS5cbkByZXR1cm5zIFRoZSBwYXJzZWQgc3RyZWFtIHBhcnQuXG5AdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlU3RyZWFtUGFydCA9IChsaW5lOiBzdHJpbmcpOiBTdHJlYW1QYXJ0VHlwZSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcblxuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuXG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cblxuICBjb25zdCBjb2RlID0gcHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZTtcblxuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlOiBKU09OVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG5cbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuXG4vKipcblByZXBlbmRzIGEgc3RyaW5nIHdpdGggYSBwcmVmaXggZnJvbSB0aGUgYFN0cmVhbUNodW5rUHJlZml4ZXNgLCBKU09OLWlmaWVzIGl0LFxuYW5kIGFwcGVuZHMgYSBuZXcgbGluZS5cblxuSXQgZW5zdXJlcyB0eXBlLXNhZmV0eSBmb3IgdGhlIHBhcnQgdHlwZSBhbmQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0PFQgZXh0ZW5kcyBrZXlvZiBTdHJlYW1QYXJ0VmFsdWVUeXBlPihcbiAgdHlwZTogVCxcbiAgdmFsdWU6IFN0cmVhbVBhcnRWYWx1ZVR5cGVbVF0sXG4pOiBTdHJlYW1TdHJpbmcge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZChwYXJ0ID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG5cbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxcbmA7XG59XG4iLCJpbXBvcnQgeyBTdHJlYW1QYXJ0VHlwZSwgcGFyc2VTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5jb25zdCBORVdMSU5FID0gJ1xcbicuY2hhckNvZGVBdCgwKTtcblxuLy8gY29uY2F0ZW5hdGVzIGFsbCB0aGUgY2h1bmtzIGludG8gYSBzaW5nbGUgVWludDhBcnJheVxuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rczogVWludDhBcnJheVtdLCB0b3RhbExlbmd0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG5cbiAgcmV0dXJuIGNvbmNhdGVuYXRlZENodW5rcztcbn1cblxuLyoqXG5Db252ZXJ0cyBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciBpbnRvIGFuIGFzeW5jIGdlbmVyYXRvciB0aGF0IHlpZWxkc1xuU3RyZWFtUGFydCBvYmplY3RzLlxuXG5AcGFyYW0gcmVhZGVyIFxuICAgICAgIFJlYWRlciBmb3IgdGhlIHN0cmVhbSB0byByZWFkIGZyb20uXG5AcGFyYW0gaXNBYm9ydGVkXG4gICAgICAgT3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZC5cbiAgICAgICBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgZ2VuZXJhdG9yIHdpbGwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgSWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlIGdlbmVyYXRvciB3aWxsIG5vdCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiByZWFkRGF0YVN0cmVhbShcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT4sXG4gIHtcbiAgICBpc0Fib3J0ZWQsXG4gIH06IHtcbiAgICBpc0Fib3J0ZWQ/OiAoKSA9PiBib29sZWFuO1xuICB9ID0ge30sXG4pOiBBc3luY0dlbmVyYXRvcjxTdHJlYW1QYXJ0VHlwZT4ge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBub3RlOiB0aGlzIHNsaWdodGx5IG1vcmUgY29tcGxleCBhbGdvcml0aG0gaXMgcmVxdWlyZWRcbiAgLy8gdG8gcGFzcyB0aGUgdGVzdHMgaW4gdGhlIGVkZ2UgZW52aXJvbm1lbnQuXG5cbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsYXN0IGNoYXJhY3RlciBpcyBub3QgYSBuZXdsaW5lLCB3ZSBoYXZlIG5vdCByZWFkIHRoZSB3aG9sZSBKU09OIHZhbHVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhazsgLy8gd2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgIH1cblxuICAgIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICBjb25zdCBzdHJlYW1QYXJ0cyA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKSAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG4gICAgICAubWFwKHBhcnNlU3RyZWFtUGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMpIHtcbiAgICAgIHlpZWxkIHN0cmVhbVBhcnQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgaWYgKGlzQWJvcnRlZD8uKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tICduYW5vaWQvbm9uLXNlY3VyZSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgNy1jaGFyYWN0ZXIgcmFuZG9tIHN0cmluZyB0byB1c2UgZm9yIElEcy4gTm90IHNlY3VyZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWQgPSBjdXN0b21BbHBoYWJldChcbiAgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgNyxcbik7XG4iLCJpbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4vcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgdHlwZSB7IEZ1bmN0aW9uQ2FsbCwgSlNPTlZhbHVlLCBNZXNzYWdlLCBUb29sQ2FsbCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY3Rpb24gfSBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxudHlwZSBQcmVmaXhNYXAgPSB7XG4gIHRleHQ/OiBNZXNzYWdlO1xuICBmdW5jdGlvbl9jYWxsPzogTWVzc2FnZSAmIHtcbiAgICByb2xlOiAnYXNzaXN0YW50JztcbiAgICBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGw7XG4gIH07XG4gIHRvb2xfY2FsbHM/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIHRvb2xfY2FsbHM6IFRvb2xDYWxsW107XG4gIH07XG4gIGRhdGE6IEpTT05WYWx1ZVtdO1xufTtcblxuZnVuY3Rpb24gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2U8VCBleHRlbmRzIE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkPihcbiAgbWVzc2FnZTogVCxcbiAgYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuKTogVCB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aCkgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH0gYXMgVDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkRnVuY3Rpb24sXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gbmV3IERhdGUoKSxcbn06IHtcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG4gIGFib3J0Q29udHJvbGxlclJlZj86IHtcbiAgICBjdXJyZW50OiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICB9O1xuICB1cGRhdGU6IChtZXJnZWQ6IE1lc3NhZ2VbXSwgZGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIG9uRmluaXNoPzogKHByZWZpeE1hcDogUHJlZml4TWFwKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkPzogKCkgPT4gc3RyaW5nO1xuICBnZXRDdXJyZW50RGF0ZT86ICgpID0+IERhdGU7XG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcDogUHJlZml4TWFwID0ge1xuICAgIGRhdGE6IFtdLFxuICB9O1xuXG4gIC8vIGtlZXAgbGlzdCBvZiBjdXJyZW50IG1lc3NhZ2UgYW5ub3RhdGlvbnMgZm9yIG1lc3NhZ2VcbiAgbGV0IG1lc3NhZ2VfYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIC8vIHdlIGNyZWF0ZSBhIG1hcCBvZiBlYWNoIHByZWZpeCwgYW5kIGZvciBlYWNoIHByZWZpeGVkIG1lc3NhZ2Ugd2UgcHVzaCB0byB0aGUgbWFwXG4gIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmPy5jdXJyZW50ID09PSBudWxsLFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbJ3RleHQnXSkge1xuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbJ3RleHQnXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwWyd0ZXh0J10uY29udGVudCB8fCAnJykgKyB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uX2NhbGwnKSB7XG4gICAgICBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICBmdW5jdGlvbl9jYWxsOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLFxuICAgICAgICBuYW1lOiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbJ2Z1bmN0aW9uX2NhbGwnXTtcbiAgICB9XG5cbiAgICBsZXQgdG9vbENhbGxNZXNzYWdlOiBNZXNzYWdlIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3Rvb2xfY2FsbHMnKSB7XG4gICAgICBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICB0b29sX2NhbGxzOiB2YWx1ZS50b29sX2NhbGxzLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICB9O1xuXG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2RhdGEnKSB7XG4gICAgICBwcmVmaXhNYXBbJ2RhdGEnXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gcHJlZml4TWFwWyd0ZXh0J107XG5cbiAgICBpZiAodHlwZSA9PT0gJ21lc3NhZ2VfYW5ub3RhdGlvbnMnKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgYW55IGV4aXN0aW5nIG1lc3NhZ2Ugd2l0aCB0aGUgbGF0ZXN0IGFubm90YXRpb25zXG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ3Rvb2xfY2FsbHMnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGtlZXBzIHRoZSBwcmVmaXhNYXAgdXAgdG8gZGF0ZSB3aXRoIHRoZSBsYXRlc3QgYW5ub3RhdGlvbnMsIGV2ZW4gaWYgYW5ub3RhdGlvbnMgcHJlY2VkZWQgdGhlIG1lc3NhZ2VcbiAgICBpZiAobWVzc2FnZV9hbm5vdGF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5czogKGtleW9mIFByZWZpeE1hcClbXSA9IFtcbiAgICAgICAgJ3RleHQnLFxuICAgICAgICAnZnVuY3Rpb25fY2FsbCcsXG4gICAgICAgICd0b29sX2NhbGxzJyxcbiAgICAgIF07XG4gICAgICBtZXNzYWdlUHJlZml4S2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwcmVmaXhNYXBba2V5XSkge1xuICAgICAgICAgIChwcmVmaXhNYXBba2V5XSBhcyBNZXNzYWdlKS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zIV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFdlIGFkZCBmdW5jdGlvbiAmIHRvb2wgY2FsbHMgYW5kIHJlc3BvbnNlIG1lc3NhZ2VzIHRvIHRoZSBtZXNzYWdlc1tdLCBidXQgZGF0YSBpcyBpdHMgb3duIHRoaW5nXG4gICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHRvb2xDYWxsTWVzc2FnZSwgcmVzcG9uc2VNZXNzYWdlXVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLm1hcChtZXNzYWdlID0+ICh7XG4gICAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpLFxuICAgICAgfSkpIGFzIE1lc3NhZ2VbXTtcblxuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbJ2RhdGEnXV0pOyAvLyBtYWtlIGEgY29weSBvZiB0aGUgZGF0YSBhcnJheVxuICB9XG5cbiAgb25GaW5pc2g/LihwcmVmaXhNYXApO1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxscyxcbiAgICBdLmZpbHRlcihCb29sZWFuKSBhcyBNZXNzYWdlW10sXG4gICAgZGF0YTogcHJlZml4TWFwLmRhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBTdHJlYW1QYXJ0VHlwZSxcbiAgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHBhcnNlU3RyZWFtUGFydCxcbn0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gVE9ETyByZW1vdmUgKGJyZWFraW5nIGNoYW5nZSlcbmV4cG9ydCB7IGdlbmVyYXRlSWQgYXMgbmFub2lkIH0gZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5cbi8vIEV4cG9ydCBzdHJlYW0gZGF0YSB1dGlsaXRpZXMgZm9yIGN1c3RvbSBzdHJlYW0gaW1wbGVtZW50YXRpb25zLFxuLy8gYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZS5cbmV4cG9ydCB0eXBlIHsgU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQsIHBhcnNlU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcblxuLy8gc2ltcGxlIGRlY29kZXIgc2lnbmF0dXJlczpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcigpOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogZmFsc2UsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbi8vIGNvbXBsZXggZGVjb2RlciBzaWduYXR1cmU6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IHRydWUsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW107XG4vLyBjb21iaW5lZCBzaWduYXR1cmUgZm9yIHdoZW4gdGhlIGNsaWVudCBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggYSBib29sZWFuOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4PzogYm9vbGVhbixcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXSB8IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4PzogYm9vbGVhbikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgICBpZiAoIWNodW5rKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpOyAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG5cbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9O1xuXG5leHBvcnQgY29uc3QgaXNTdHJlYW1TdHJpbmdFcXVhbFRvVHlwZSA9IChcbiAgdHlwZToga2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzLFxuICB2YWx1ZTogc3RyaW5nLFxuKTogdmFsdWUgaXMgU3RyZWFtU3RyaW5nID0+XG4gIHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtU3RyaW5nID1cbiAgYCR7KHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcylba2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzXX06JHtzdHJpbmd9XFxuYDtcbiIsImltcG9ydCB7IHBhcnNlQ29tcGxleFJlc3BvbnNlIH0gZnJvbSAnLi9wYXJzZS1jb21wbGV4LXJlc3BvbnNlJztcbmltcG9ydCB7IElkR2VuZXJhdG9yLCBKU09OVmFsdWUsIE1lc3NhZ2UgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIG1lc3NhZ2VzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlID0gJ3N0cmVhbS1kYXRhJyxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBtZXNzYWdlczogT21pdDxNZXNzYWdlLCAnaWQnPltdO1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBzdHJlYW1Nb2RlPzogJ3N0cmVhbS1kYXRhJyB8ICd0ZXh0JztcbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgYWJvcnRDb250cm9sbGVyPzogKCkgPT4gQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlOiAoKSA9PiB2b2lkO1xuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uVXBkYXRlOiAobWVyZ2VkOiBNZXNzYWdlW10sIGRhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkOiBJZEdlbmVyYXRvcjtcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIC4uLmJvZHksXG4gICAgfSksXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfSxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlcj8uKCk/LnNpZ25hbCxcbiAgICBjcmVkZW50aWFscyxcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuXG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAoYXdhaXQgcmVzcG9uc2UudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gIH1cblxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gIHN3aXRjaCAoc3RyZWFtTW9kZSkge1xuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdE1lc3NhZ2UgPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdE1lc3NhZ2UuY29udGVudCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0TWVzc2FnZS5pZCA9IGdlbmVyYXRlSWQoKTtcblxuICAgICAgICAvLyBub3RlOiBjcmVhdGluZyBhIG5ldyBtZXNzYWdlIG9iamVjdCBpcyByZXF1aXJlZCBmb3IgU29saWQuanMgc3RyZWFtaW5nXG4gICAgICAgIG9uVXBkYXRlKFt7IC4uLnJlc3VsdE1lc3NhZ2UgfV0sIFtdKTtcblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcj8uKCkgPT09IG51bGwpIHtcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25GaW5pc2g/LihyZXN1bHRNZXNzYWdlKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZXM6IFtyZXN1bHRNZXNzYWdlXSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgJ3N0cmVhbS1kYXRhJzoge1xuICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgICAgICAgcmVhZGVyLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWY6XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyICE9IG51bGwgPyB7IGN1cnJlbnQ6IGFib3J0Q29udHJvbGxlcigpIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uRmluaXNoKHByZWZpeE1hcCkge1xuICAgICAgICAgIGlmIChvbkZpbmlzaCAmJiBwcmVmaXhNYXAudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXAudGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW5lcmF0ZUlkLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHN0cmVhbU1vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIG1vZGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQ2hhdFJlcXVlc3QsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBNZXNzYWdlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHVwZGF0ZUNoYXRSZXF1ZXN0LFxuICBnZXRDdXJyZW50TWVzc2FnZXMsXG59OiB7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+IFByb21pc2U8XG4gICAgTWVzc2FnZSB8IHsgbWVzc2FnZXM6IE1lc3NhZ2VbXTsgZGF0YTogSlNPTlZhbHVlW10gfVxuICA+O1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgZnVuY3Rpb25DYWxsOiBGdW5jdGlvbkNhbGwsXG4gICkgPT4gUHJvbWlzZTx2b2lkIHwgQ2hhdFJlcXVlc3Q+O1xuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbD86IChcbiAgICBjaGF0TWVzc2FnZXM6IE1lc3NhZ2VbXSxcbiAgICB0b29sQ2FsbHM6IFRvb2xDYWxsW10sXG4gICkgPT4gUHJvbWlzZTx2b2lkIHwgQ2hhdFJlcXVlc3Q+O1xuICB1cGRhdGVDaGF0UmVxdWVzdDogKGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCkgPT4gdm9pZDtcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBNZXNzYWdlW107XG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBUaGlzIHNob3VsZCBiZSB7ICBjb25zdCB7IG1lc3NhZ2VzOiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZXMsIGRhdGEgfSA9XG4gICAgLy8gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSh9IG9uY2UgU3RyZWFtIERhdGEgaXMgbm90IGV4cGVyaW1lbnRhbFxuICAgIGNvbnN0IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UgPSBhd2FpdCBnZXRTdHJlYW1lZFJlc3BvbnNlKCk7XG5cbiAgICAvLyBVc2luZyBleHBlcmltZW50YWwgc3RyZWFtIGRhdGFcbiAgICBpZiAoJ21lc3NhZ2VzJyBpbiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlKSB7XG4gICAgICBsZXQgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgLy8gU2VlIGlmIHRoZSBtZXNzYWdlIGhhcyBhIGNvbXBsZXRlIGZ1bmN0aW9uIGNhbGwgb3IgdG9vbCBjYWxsXG4gICAgICAgIGlmIChcbiAgICAgICAgICAobWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgIChtZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gJ3N0cmluZycpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb25DYWxsIGlzIGFuIG9iamVjdFxuICAgICAgICAgIC8vIElmIG5vdCwgd2UgZ290IHRvb2wgY2FsbHMgaW5zdGVhZCBvZiBmdW5jdGlvbiBjYWxsc1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuY3Rpb25DYWxsICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuXG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlcygpLFxuICAgICAgICAgICAgICBmdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSB0byBoYW5kbGUgdG9vbCBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbENhbGxzIGlzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCBmdW5jdGlvbiBjYWxscyBpbnN0ZWFkIG9mIHRvb2wgY2FsbHNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0b29sQ2FsbHMpIHx8XG4gICAgICAgICAgICB0b29sQ2FsbHMuc29tZSh0b29sQ2FsbCA9PiB0eXBlb2YgdG9vbENhbGwgIT09ICdvYmplY3QnKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVzZXIgaGFuZGxlcyB0aGUgZnVuY3Rpb24gY2FsbCBpbiB0aGVpciBvd24gZnVuY3Rpb25DYWxsSGFuZGxlci5cbiAgICAgICAgICAvLyBUaGUgXCJhcmd1bWVudHNcIiBrZXkgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgb2JqZWN0IHdpbGwgc3RpbGwgYmUgYSBzdHJpbmcgd2hpY2ggd2lsbCBoYXZlIHRvIGJlIHBhcnNlZCBpbiB0aGUgZnVuY3Rpb24gaGFuZGxlci5cbiAgICAgICAgICAvLyBJZiB0aGUgXCJhcmd1bWVudHNcIiBKU09OIGlzIG1hbGZvcm1lZCBkdWUgdG8gbW9kZWwgZXJyb3IgdGhlIHVzZXIgd2lsbCBoYXZlIHRvIGhhbmRsZSB0aGF0IHRoZW1zZWx2ZXMuXG4gICAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAgIC8vIFRoZSB1cGRhdGVkIGNoYXQgd2l0aCBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdpbGwgYmUgc2VudCB0byB0aGUgQVBJIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgbG9vcC5cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuXG4gICAgICAvLyBUT0RPLVNUUkVBTURBVEE6IFJlbW92ZSB0aGlzIG9uY2UgU3RyZWFtIERhdGEgaXMgbm90IGV4cGVyaW1lbnRhbFxuICAgICAgaWYgKFxuICAgICAgICAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIGZ1bmN0aW9uIGNhbGwsIHRoZSBtZXNzYWdlIHNob3VsZCBoYXZlIG9uZSwgaWYgbm90IHdhcm4gYW5kIGNvbnRpbnVlXG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgIGlmICghKHR5cGVvZiBmdW5jdGlvbkNhbGwgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCBmdW5jdGlvbkNhbGwpO1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGdldCBoZXJlIGFuZCBhcmUgZXhwZWN0aW5nIGEgdG9vbCBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgIGlmICghKHR5cGVvZiB0b29sQ2FsbHMgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdleHBlcmltZW50YWxfb25Ub29sQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyBmdW5jdGlvbnMnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZTogQ2hhdFJlcXVlc3QgfCB2b2lkID1cbiAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAvLyBBIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2FzIHJldHVybmVkLlxuICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cyBhcmUgc2VudCBiYWNrIHRvIHRoZSBBUEkgYXMgYSBzdHJpbmdcbiAgICAgIGZ1bmN0aW9uIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyhyZXNwb25zZTogQ2hhdFJlcXVlc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlc3BvbnNlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvb2xDYWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAmJlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InO1xuaW1wb3J0IHsgY2FsbENvbXBsZXRpb25BcGkgfSBmcm9tICcuLi9zaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaSc7XG5pbXBvcnQge1xuICBKU09OVmFsdWUsXG4gIFJlcXVlc3RPcHRpb25zLFxuICBVc2VDb21wbGV0aW9uT3B0aW9ucyxcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgeyBVc2VDb21wbGV0aW9uT3B0aW9ucyB9O1xuXG5leHBvcnQgdHlwZSBVc2VDb21wbGV0aW9uSGVscGVycyA9IHtcbiAgLyoqIFRoZSBjdXJyZW50IGNvbXBsZXRpb24gcmVzdWx0ICovXG4gIGNvbXBsZXRpb246IHN0cmluZztcbiAgLyoqXG4gICAqIFNlbmQgYSBuZXcgcHJvbXB0IHRvIHRoZSBBUEkgZW5kcG9pbnQgYW5kIHVwZGF0ZSB0aGUgY29tcGxldGlvbiBzdGF0ZS5cbiAgICovXG4gIGNvbXBsZXRlOiAoXG4gICAgcHJvbXB0OiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zLFxuICApID0+IFByb21pc2U8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG4gIC8qKiBUaGUgZXJyb3Igb2JqZWN0IG9mIHRoZSBBUEkgcmVxdWVzdCAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgRXJyb3I7XG4gIC8qKlxuICAgKiBBYm9ydCB0aGUgY3VycmVudCBBUEkgcmVxdWVzdCBidXQga2VlcCB0aGUgZ2VuZXJhdGVkIHRva2Vucy5cbiAgICovXG4gIHN0b3A6ICgpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGBjb21wbGV0aW9uYCBzdGF0ZSBsb2NhbGx5LlxuICAgKi9cbiAgc2V0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgLyoqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBpbnB1dDogc3RyaW5nO1xuICAvKiogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIC8qKlxuICAgKiBBbiBpbnB1dC90ZXh0YXJlYS1yZWFkeSBvbkNoYW5nZSBoYW5kbGVyIHRvIGNvbnRyb2wgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogPGlucHV0IG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gdmFsdWU9e2lucHV0fSAvPlxuICAgKiBgYGBcbiAgICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZTpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRvIGF1dG9tYXRpY2FsbHkgcmVzZXQgaW5wdXQgYW5kIGFwcGVuZCBhIHVzZXIgbWVzc2FnZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc3hcbiAgICogPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0+XG4gICAqICA8aW5wdXQgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSB2YWx1ZT17aW5wdXR9IC8+XG4gICAqIDwvZm9ybT5cbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGVTdWJtaXQ6IChlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4gdm9pZDtcbiAgLyoqIFdoZXRoZXIgdGhlIEFQSSByZXF1ZXN0IGlzIGluIHByb2dyZXNzICovXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgLyoqIEFkZGl0aW9uYWwgZGF0YSBhZGRlZCBvbiB0aGUgc2VydmVyIHZpYSBTdHJlYW1EYXRhICovXG4gIGRhdGE/OiBKU09OVmFsdWVbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wbGV0aW9uKHtcbiAgYXBpID0gJy9hcGkvY29tcGxldGlvbicsXG4gIGlkLFxuICBpbml0aWFsQ29tcGxldGlvbiA9ICcnLFxuICBpbml0aWFsSW5wdXQgPSAnJyxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxufTogVXNlQ29tcGxldGlvbk9wdGlvbnMgPSB7fSk6IFVzZUNvbXBsZXRpb25IZWxwZXJzIHtcbiAgLy8gR2VuZXJhdGUgYW4gdW5pcXVlIGlkIGZvciB0aGUgY29tcGxldGlvbiBpZiBub3QgcHJvdmlkZWQuXG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGNvbXBsZXRpb25JZCA9IGlkIHx8IGhvb2tJZDtcblxuICAvLyBTdG9yZSB0aGUgY29tcGxldGlvbiBzdGF0ZSBpbiBTV1IsIHVzaW5nIHRoZSBjb21wbGV0aW9uSWQgYXMgdGhlIGtleSB0byBzaGFyZSBzdGF0ZXMuXG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1I8c3RyaW5nPihbYXBpLCBjb21wbGV0aW9uSWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsQ29tcGxldGlvbixcbiAgfSk7XG5cbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1I8Ym9vbGVhbj4oXG4gICAgW2NvbXBsZXRpb25JZCwgJ2xvYWRpbmcnXSxcbiAgICBudWxsLFxuICApO1xuXG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1I8XG4gICAgSlNPTlZhbHVlW10gfCB1bmRlZmluZWRcbiAgPihbY29tcGxldGlvbklkLCAnc3RyZWFtRGF0YSddLCBudWxsKTtcblxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHVuZGVmaW5lZCB8IEVycm9yPih1bmRlZmluZWQpO1xuICBjb25zdCBjb21wbGV0aW9uID0gZGF0YSE7XG5cbiAgLy8gQWJvcnQgY29udHJvbGxlciB0byBjYW5jZWwgdGhlIGN1cnJlbnQgQVBJIGNhbGwuXG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPVxuICAgIHVzZVN0YXRlPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcblxuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChwcm9tcHQ6IHN0cmluZywgb3B0aW9ucz86IFJlcXVlc3RPcHRpb25zKSA9PlxuICAgICAgY2FsbENvbXBsZXRpb25BcGkoe1xuICAgICAgICBhcGksXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICAgICAgaGVhZGVyczogeyAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAgICAgLi4ub3B0aW9ucz8uYm9keSxcbiAgICAgICAgfSxcbiAgICAgICAgc3RyZWFtTW9kZSxcbiAgICAgICAgc2V0Q29tcGxldGlvbjogY29tcGxldGlvbiA9PiBtdXRhdGUoY29tcGxldGlvbiwgZmFsc2UpLFxuICAgICAgICBzZXRMb2FkaW5nOiBtdXRhdGVMb2FkaW5nLFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25EYXRhOiBkYXRhID0+IHtcbiAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi4oc3RyZWFtRGF0YSB8fCBbXSksIC4uLihkYXRhIHx8IFtdKV0sIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbU1vZGUsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcblxuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgKGNvbXBsZXRpb246IHN0cmluZykgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24sIGZhbHNlKTtcbiAgICB9LFxuICAgIFttdXRhdGVdLFxuICApO1xuXG4gIGNvbnN0IGNvbXBsZXRlID0gdXNlQ2FsbGJhY2s8VXNlQ29tcGxldGlvbkhlbHBlcnNbJ2NvbXBsZXRlJ10+KFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChwcm9tcHQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XSxcbiAgKTtcblxuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKGluaXRpYWxJbnB1dCk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm47XG4gICAgICByZXR1cm4gY29tcGxldGUoaW5wdXQpO1xuICAgIH0sXG4gICAgW2lucHV0LCBjb21wbGV0ZV0sXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZTogYW55KSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHsgSlNPTlZhbHVlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlID0gJ3N0cmVhbS1kYXRhJyxcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIG9uRGF0YSxcbn06IHtcbiAgYXBpOiBzdHJpbmc7XG4gIHByb21wdDogc3RyaW5nO1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0O1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBzdHJlYW1Nb2RlPzogJ3N0cmVhbS1kYXRhJyB8ICd0ZXh0JztcbiAgc2V0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0TG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldEVycm9yOiAoZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBzZXRBYm9ydENvbnRyb2xsZXI6IChhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGwpID0+IHZvaWQ7XG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25GaW5pc2g/OiAocHJvbXB0OiBzdHJpbmcsIGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIG9uRGF0YT86IChkYXRhOiBKU09OVmFsdWVbXSkgPT4gdm9pZDtcbn0pIHtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG5cbiAgICAvLyBFbXB0eSB0aGUgY29tcGxldGlvbiBpbW1lZGlhdGVseS5cbiAgICBzZXRDb21wbGV0aW9uKCcnKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keSxcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG5cbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoYXdhaXQgcmVzLnRleHQoKSkgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgIHN3aXRjaCAoc3RyZWFtTW9kZSkge1xuICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBjb21wbGV0aW9uIHN0YXRlIHdpdGggdGhlIG5ldyBtZXNzYWdlIHRva2Vucy5cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuXG4gICAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3N0cmVhbS1kYXRhJzoge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICAgICAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RhdGEnOiB7XG4gICAgICAgICAgICAgIG9uRGF0YT8uKHZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBzdHJlYW1Nb2RlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIG1vZGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cblxuICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzIGFzIHRoZXkgYXJlIGV4cGVjdGVkLlxuICAgIGlmICgoZXJyIGFzIGFueSkubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRFcnJvcihlcnIgYXMgRXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcyAqL1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmF0ZS1pZCc7XG5pbXBvcnQgeyByZWFkRGF0YVN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB7IENyZWF0ZU1lc3NhZ2UsIE1lc3NhZ2UgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBBc3Npc3RhbnRTdGF0dXMgPSAnaW5fcHJvZ3Jlc3MnIHwgJ2F3YWl0aW5nX21lc3NhZ2UnO1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRIZWxwZXJzID0ge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgYXJyYXkgb2YgY2hhdCBtZXNzYWdlcy5cbiAgICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG5cbiAgLyoqXG4gICAqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgbWVzc2FnZXMgYXJyYXkuXG4gICAqL1xuICBzZXRNZXNzYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248TWVzc2FnZVtdPj47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVhZCBJRC5cbiAgICovXG4gIHRocmVhZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIGlucHV0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0gcmVxdWVzdE9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgdGhlIGBvbkNoYW5nZWAgZXZlbnQgb2YgdGhlIGlucHV0IGZpZWxkIHRvIGNvbnRyb2wgdGhlIGlucHV0J3MgdmFsdWUuXG4gICAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGV2ZW50OlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0aGF0IGF1dG9tYXRpY2FsbHkgcmVzZXRzIHRoZSBpbnB1dCBmaWVsZCBhbmQgYXBwZW5kcyBhIHVzZXIgbWVzc2FnZS5cbiAgICovXG4gIHN1Ym1pdE1lc3NhZ2U6IChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzaG93IGEgbG9hZGluZyBpbmRpY2F0b3IuXG4gICAqL1xuICBzdGF0dXM6IEFzc2lzdGFudFN0YXR1cztcblxuICAvKipcbiAgICogVGhlIGVycm9yIHRocm93biBkdXJpbmcgdGhlIGFzc2lzdGFudCBtZXNzYWdlIHByb2Nlc3NpbmcsIGlmIGFueS5cbiAgICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCB1bmtub3duO1xufTtcblxuZXhwb3J0IHR5cGUgVXNlQXNzaXN0YW50T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIFRoZSBBUEkgZW5kcG9pbnQgdGhhdCBhY2NlcHRzIGEgYHsgdGhyZWFkSWQ6IHN0cmluZyB8IG51bGw7IG1lc3NhZ2U6IHN0cmluZzsgfWAgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGBBc3Npc3RhbnRSZXNwb25zZWAgc3RyZWFtLlxuICAgKiBUaGUgdGhyZWFkSWQgcmVmZXJzIHRvIGFuIGV4aXN0aW5nIHRocmVhZCB3aXRoIG1lc3NhZ2VzIChvciBpcyBgbnVsbGAgdG8gY3JlYXRlIGEgbmV3IHRocmVhZCkuXG4gICAqIFRoZSBtZXNzYWdlIGlzIHRoZSBuZXh0IG1lc3NhZ2UgdGhhdCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIHRocmVhZCBhbmQgc2VudCB0byB0aGUgYXNzaXN0YW50LlxuICAgKi9cbiAgYXBpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIElEIG9mIGFuIGV4aXN0aW5nIHRocmVhZC5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBhIG5ldyB0aHJlYWQgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgdGhyZWFkSWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIGxpdGVyYWwgdGhhdCBzZXRzIHRoZSBtb2RlIG9mIGNyZWRlbnRpYWxzIHRvIGJlIHVzZWQgb24gdGhlIHJlcXVlc3QuXG4gICAqIERlZmF1bHRzIHRvIFwic2FtZS1vcmlnaW5cIi5cbiAgICovXG4gIGNyZWRlbnRpYWxzPzogUmVxdWVzdENyZWRlbnRpYWxzO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBvYmplY3Qgb2YgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIEFQSSBlbmRwb2ludC5cbiAgICovXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgSGVhZGVycztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgYm9keSBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBBUEkgZW5kcG9pbnQuXG4gICAqL1xuICBib2R5Pzogb2JqZWN0O1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc2lzdGFudCBlbmNvdW50ZXJzIGFuIGVycm9yLlxuICAgKi9cbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXNzaXN0YW50KHtcbiAgYXBpLFxuICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIG9uRXJyb3IsXG59OiBVc2VBc3Npc3RhbnRPcHRpb25zKTogVXNlQXNzaXN0YW50SGVscGVycyB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbdGhyZWFkSWQsIHNldFRocmVhZElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IHVzZVN0YXRlPEFzc2lzdGFudFN0YXR1cz4oJ2F3YWl0aW5nX21lc3NhZ2UnKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBFcnJvcj4odW5kZWZpbmVkKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChcbiAgICBldmVudDpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4ge1xuICAgIHNldElucHV0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgY29uc3QgYXBwZW5kID0gYXN5bmMgKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgc2V0U3RhdHVzKCdpbl9wcm9ncmVzcycpO1xuXG4gICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkID8/IGdlbmVyYXRlSWQoKSxcbiAgICAgIH0sXG4gICAgXSk7XG5cbiAgICBzZXRJbnB1dCgnJyk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBjcmVkZW50aWFscyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgIC8vIGFsd2F5cyB1c2UgdXNlci1wcm92aWRlZCB0aHJlYWRJZCB3aGVuIGF2YWlsYWJsZTpcbiAgICAgICAgICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSA/PyB0aHJlYWRJZCA/PyBudWxsLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UuY29udGVudCxcblxuICAgICAgICAgIC8vIG9wdGlvbmFsIHJlcXVlc3QgZGF0YTpcbiAgICAgICAgICBkYXRhOiByZXF1ZXN0T3B0aW9ucz8uZGF0YSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgICAgIH1cblxuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0oXG4gICAgICAgIHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLFxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdhc3Npc3RhbnRfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAvLyB0ZXh0IGRlbHRhIC0gYWRkIHRvIGxhc3QgbWVzc2FnZTpcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5tZXNzYWdlcy5zbGljZSgwLCBtZXNzYWdlcy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogbGFzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICByb2xlOiBsYXN0TWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogbGFzdE1lc3NhZ2UuY29udGVudCArIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGF0YV9tZXNzYWdlJzoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCA/PyBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpZCBvZiBsYXN0IG1lc3NhZ2U6XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VzLmxlbmd0aCAtIDEpLCBsYXN0TWVzc2FnZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck9iaiA9IG5ldyBFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck9iaik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgc2V0RXJyb3IoZXJyb3IgYXMgRXJyb3IpO1xuICAgIH1cblxuICAgIHNldFN0YXR1cygnYXdhaXRpbmdfbWVzc2FnZScpO1xuICB9O1xuXG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoXG4gICAgZXZlbnQ/OiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PixcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4ge1xuICAgIGV2ZW50Py5wcmV2ZW50RGVmYXVsdD8uKCk7XG5cbiAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXBwZW5kKHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiBpbnB1dCB9LCByZXF1ZXN0T3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBhcHBlbmQsXG4gICAgbWVzc2FnZXMsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgdGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gIH07XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGB1c2VBc3Npc3RhbnRgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50ID0gdXNlQXNzaXN0YW50O1xuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlSWQiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZVNXUiIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsInZhbHVlIiwiRXJyb3IiLCJ0eXBlIiwiZnVuY3Rpb25DYWxsU3RyZWFtUGFydCIsImZ1bmN0aW9uX2NhbGwiLCJhcmd1bWVudHMiLCJkYXRhU3RyZWFtUGFydCIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yU3RyZWFtUGFydCIsImFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0IiwiaWQiLCJyb2xlIiwiY29udGVudCIsImV2ZXJ5IiwiaXRlbSIsInRleHQiLCJhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQiLCJ0aHJlYWRJZCIsIm1lc3NhZ2VJZCIsImRhdGFNZXNzYWdlU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xfY2FsbHMiLCJzb21lIiwidGMiLCJmdW5jdGlvbiIsIm1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0cyIsInN0cmVhbVBhcnRzQnlDb2RlIiwiU3RyZWFtU3RyaW5nUHJlZml4ZXMiLCJ2YWxpZENvZGVzIiwibWFwIiwicGFydCIsInBhcnNlU3RyZWFtUGFydCIsImxpbmUiLCJmaXJzdFNlcGFyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwiaW5jbHVkZXMiLCJ0ZXh0VmFsdWUiLCJqc29uVmFsdWUiLCJKU09OIiwiTkVXTElORSIsImNoYXJDb2RlQXQiLCJjb25jYXRDaHVua3MiLCJjaHVua3MiLCJ0b3RhbExlbmd0aCIsImNvbmNhdGVuYXRlZENodW5rcyIsIlVpbnQ4QXJyYXkiLCJvZmZzZXQiLCJjaHVuayIsInNldCIsImxlbmd0aCIsInJlYWREYXRhU3RyZWFtIiwicmVhZGVyIiwiaXNBYm9ydGVkIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwicmVhZCIsInB1c2giLCJkZWNvZGUiLCJzdHJlYW0iLCJzcGxpdCIsImZpbHRlciIsInN0cmVhbVBhcnQiLCJjYW5jZWwiLCJjdXN0b21BbHBoYWJldCIsImdlbmVyYXRlSWQiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZXRDdXJyZW50RGF0ZSIsIkRhdGUiLCJjcmVhdGVkQXQiLCJwcmVmaXhNYXAiLCJkYXRhIiwibWVzc2FnZV9hbm5vdGF0aW9ucyIsImN1cnJlbnQiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwidG9vbENhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVzc2FnZVByZWZpeEtleXMiLCJmb3JFYWNoIiwia2V5IiwibWVyZ2VkIiwiQm9vbGVhbiIsIm1lc3NhZ2VzIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZWQiLCJjYWxsQ2hhdEFwaSIsImFwaSIsImJvZHkiLCJzdHJlYW1Nb2RlIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsInJlc3VsdE1lc3NhZ2UiLCJkb25lIiwiZXhoYXVzdGl2ZUNoZWNrIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsImZ1bmN0aW9uQ2FsbCIsImNvbnNvbGUiLCJ3YXJuIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2UiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsInRvb2xDYWxsUmVzcG9uc2UiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMiLCJzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSIsImNoYXRSZXF1ZXN0IiwibXV0YXRlIiwibXV0YXRlU3RyZWFtRGF0YSIsImV4aXN0aW5nRGF0YSIsImV4dHJhTWV0YWRhdGFSZWYiLCJtZXNzYWdlc1JlZiIsInNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMiLCJfYiIsInByZXZpb3VzTWVzc2FnZXMiLCJjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCIsInRvb2xfY2FsbF9pZCIsInJlcGx5SWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJyZXN1bHQiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGUiLCJ1c2VBc3Npc3RhbnQiLCJ0aHJlYWRJZFBhcmFtIiwic2V0VGhyZWFkSWQiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJldmVudCIsInJlcXVlc3RPcHRpb25zIiwiZXJyb3JPYmoiLCJzdWJtaXRNZXNzYWdlIiwiY2FsbCIsImV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;